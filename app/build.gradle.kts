import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
/*
 * This file was generated by the Gradle 'init' task.
 *
 * This project uses @Incubating APIs which are subject to change.
 */

plugins {
    id("buildlogic.kotlin-application-conventions")
    application
    id("com.github.johnrengelman.shadow") version "8.1.1"
}

dependencies {
    implementation(project(":utilities"))
    testImplementation(libs.junit.jupiter)
}

application {
    // Define the main class for the application.
    mainClass = "MainKt"
}
tasks.jar {
    manifest {
        attributes["Main-Class"] = "MainKt"
    }
}

// Ensure the shadow JAR has the "-all" classifier and inherits the manifest
tasks.named<ShadowJar>("shadowJar") {
    archiveClassifier.set("all")
    // If you need service file merging in the future, keep this handy:
    // mergeServiceFiles()
}
tasks.named<JavaExec>("runShadow") {
    standardInput = System.`in`

}
/* We are using 2 gradle run tasks because I
 * don't want to support a test task that builds
 * a shadow jar. If I test then run the shadow
 * jar, then I'm building 2 jars, which is unnecessary.
 *
 * Why don't I just make the test task use the shadow
 * jar? I don't feel like it.
 */
tasks.named<JavaExec>("run") {
    standardInput = System.`in`

}